#include <gkg-processing-plugin-nifti/NiftiDiskFormat.h>
#include <gkg-core-io/DiskFormatFactory_i.h>
#include <gkg-communication-sysinfo/ConfigurationInfo.h>
#include <gkg-core-io/TypedDiskFormat_i.h>
#include <gkg-core-io/ByteOrder.h>
#include <gkg-processing-container/Volume_i.h>
#include <gkg-core-io/TypeOf.h>
#include <gkg-core-exception/FileNotFoundException.h>
#include <gkg-core-exception/ObjectTypeException.h>
#include <gkg-core-exception/ItemTypeException.h>
#include <gkg-core-exception/WrongFormatException.h>
#include <gkg-core-exception/InconsistentHeaderException.h>
#include <gkg-processing-algobase/Math.h>
#include <gkg-processing-transform/Scaling3d.h>
#include <gkg-processing-transform/HomogeneousTransform3d.h>
#include <gkg-core-object/GenericObject_i.h>
#include <gkg-core-exception/Exception.h>
#include <fstream>

#include <algorithm>


template < class T >
gkg::NiftiDiskFormat< T >::NiftiDiskFormat()
                          : gkg::TypedDiskFormat< gkg::Volume< T > >()
{

  this->_extensions.insert( ".hdr" );
  this->_extensions.insert( ".img" );
  this->_extensions.insert( ".hdr.gz" );
  this->_extensions.insert( ".img.gz" );
  this->_extensions.insert( ".nii" );
  this->_extensions.insert( ".nii.gz" );
  this->_extensions.insert( getHeaderExtension() );

}


template < class T >
gkg::NiftiDiskFormat< T >::~NiftiDiskFormat()
{
}


template < class T >
std::string gkg::NiftiDiskFormat< T >::getName() const
{

  return "nifti";

}


template < class T >
void gkg::NiftiDiskFormat< T >::readHeader( const std::string& name,
                                            gkg::HeaderedObject& object ) const
{

  try
  {

    // first we add all NIFTI specific attributes
    object.addSemantic( "__nifti__", "resolutionX",
                        gkg::Semantic( gkg::TypeOf< double >::getName() ) );
    object.addSemantic( "__nifti__", "resolutionY",
                        gkg::Semantic( gkg::TypeOf< double >::getName() ) );
    object.addSemantic( "__nifti__", "resolutionZ",
                        gkg::Semantic( gkg::TypeOf< double >::getName() ) );
    object.addSemantic( "__nifti__", "resolutionT",
                        gkg::Semantic( gkg::TypeOf< double >::getName() ) );
    object.addSemantic( "__nifti__", "nifti_to_gkg_transform3d",
                        gkg::Semantic(
                                 gkg::TypeOf< std::vector< float > >::getName(),
                                 false,
                                 true ) );

    // reading the meta-information header
    bool hasStdHeader = false;
    try
    {

      this->gkg::DiskFormat::readHeader( name, object );
      hasStdHeader = true;

      // compatibility between AIMS and GKG : adding the following fields 
      // when reading data generated from AIMS command lines
      // - data_type -> item_type
      // - volume_dimension -> sizeX, sizeY, sizeZ, sizeT
      // - voxel_size -> resolutionX, resolutionY, resolutionZ, resolutionT
      if ( object.getHeader().hasAttribute( "data_type" ) &&
           !object.getHeader().hasAttribute( "item_type" ) )
      {

        std::string data_type;
        object.getHeader().getAttribute( "data_type", data_type );
        if ( data_type == getTypeName() )
        {

          object.getHeader().addAttribute( "item_type",
                                           gkg::TypeOf< T >::getName() );

        }
        else
        {

          throw gkg::ItemTypeException( this->getNameWithoutExtension( name ) +
                                        getHeaderExtension() );

        }

      }
      if ( object.getHeader().hasAttribute( "volume_dimension" ) &&
           ( !object.getHeader().hasAttribute( "sizeX" ) ||
             !object.getHeader().hasAttribute( "sizeY" ) ||
             !object.getHeader().hasAttribute( "sizeZ" ) ||
             !object.getHeader().hasAttribute( "sizeT" ) ) )
      {

        gkg::GenericObjectList volume_dimension;
        object.getHeader().getAttribute( "volume_dimension", volume_dimension );
        object.getHeader().addAttribute(
                      "sizeX",
                      ( int32_t )( volume_dimension[ 0 ]->getScalar() + 0.5 ) );
        object.getHeader().addAttribute(
                      "sizeY",
                      ( int32_t )( volume_dimension[ 1 ]->getScalar() + 0.5 ) );
        object.getHeader().addAttribute(
                      "sizeZ",
                      ( int32_t )( volume_dimension[ 2 ]->getScalar() + 0.5 ) );
        object.getHeader().addAttribute(
                      "sizeT",
                      ( int32_t )( volume_dimension[ 3 ]->getScalar() + 0.5 ) );

      }
      if ( object.getHeader().hasAttribute( "voxel_size" ) &&
           ( !object.getHeader().hasAttribute( "resolutionX" ) ||
             !object.getHeader().hasAttribute( "resolutionY" ) ||
             !object.getHeader().hasAttribute( "resolutionZ" ) ||
             !object.getHeader().hasAttribute( "resolutionT" ) ) )
      {

        gkg::GenericObjectList voxel_size;
        object.getHeader().getAttribute( "voxel_size", voxel_size );
        object.getHeader().addAttribute(
                      "resolutionX", voxel_size[ 0 ]->getScalar() );
        object.getHeader().addAttribute(
                      "resolutionY", voxel_size[ 1 ]->getScalar() );
        object.getHeader().addAttribute(
                      "resolutionZ", voxel_size[ 2 ]->getScalar() );
        object.getHeader().addAttribute(
                      "resolutionT", voxel_size[ 3 ]->getScalar() );

      }

    }
    catch ( gkg::FileNotFoundException& e )
    {

      // std::cerr << e.what() << ", "
      //           << "meta-information not present"
      //           << std::endl;

    }
    catch ( std::exception& e )
    {

      throw std::runtime_error( e.what() );

    }

    // checking that it is a volume
    std::string objectType;
    object.getHeader().getAttribute( "object_type", objectType );
    if ( objectType != "Volume" )
    {

      throw gkg::ObjectTypeException( this->getNameWithoutExtension( name ) +
                                      getHeaderExtension() );

    }

    // checking that it has the good item type
    std::string itemType;
    object.getHeader().getAttribute( "item_type", itemType );
    if ( ! gkg::TypeOf< T >::isSameType( itemType ) )
    {

      throw gkg::ItemTypeException( this->getNameWithoutExtension( name ) +
                                    getHeaderExtension() );

    }

    // setting debug level for status reporting
    nifti_set_debug_level( 0 );

    // checking that it is NIFTI file
    if ( !is_nifti_file( this->getNameWithoutExtension( name ).c_str() ) )
    {
      throw gkg::WrongFormatException( this->getNameWithoutExtension( name ) );

    }

    // reading the NIFTI header
    nifti_image* niftiImage =
      nifti_image_read( this->getNameWithoutExtension( name ).c_str(), 0 );

    if ( !niftiImage )
    {

      throw gkg::FileNotFoundException( this->getNameWithoutExtension( name ) + 
                                        ".hdr|.hdr.gz|.nii|.nii.gz" );

    }

    // adding NIFTI dictionary to object header
    gkg::Dictionary niftiDictionary;
    fillNiftiDictionary( niftiImage, niftiDictionary ); 
    object.getHeader().addAttribute( "nifti", niftiDictionary );

    std::cout << "getShortType()=" << getShortType() << std::endl;
    std::cout << "niftiImage->datatype=" << niftiImage->datatype << std::endl;

    int16_t datatype = niftiImage->datatype;
    if ( ( niftiImage->scl_slope != 0.0 ) &&
         ( ( niftiImage->scl_slope != 1.0 ) ||
           ( niftiImage->scl_inter != 0.0 ) ) )
    {

      if ( niftiImage->datatype != DT_DOUBLE )
      {

        datatype = DT_FLOAT;

      }

    }

    // checking that it is the good NIFTI type
    if ( datatype != getShortType() )
    {

      throw gkg::ItemTypeException( this->getNameWithoutExtension( name ) +
                                    ".hdr|.hdr.gz|.nii|.nii.gz" );

    }


    // building NIFTI to GKG transformation
    // NIFTI convention is +x=Right, +y=Anterior, +z=Superior
    // GKG convention is +x=Left, +y=Posterior, +z=Inferior
    int iDirection, jDirection, kDirection;


    if ( niftiImage->qform_code > NIFTI_XFORM_UNKNOWN )
    {

      nifti_mat44_to_orientation( niftiImage->qto_xyz,
                                  &iDirection,
                                  &jDirection,
                                  &kDirection );

    }
    else if ( niftiImage->sform_code > NIFTI_XFORM_UNKNOWN )
    {

      nifti_mat44_to_orientation( niftiImage->sto_xyz,
                                  &iDirection,
                                  &jDirection,
                                  &kDirection );

    }
    else
    {

      iDirection = NIFTI_L2R;
      jDirection = NIFTI_P2A;
      kDirection = NIFTI_I2S;

    }
    float d00 = 0.0, d01 = 0.0, d02 = 0.0, d03 = 0.0;
    float d10 = 0.0, d11 = 0.0, d12 = 0.0, d13 = 0.0;
    float d20 = 0.0, d21 = 0.0, d22 = 0.0, d23 = 0.0;
    float d30 = 0.0, d31 = 0.0, d32 = 0.0, d33 = 1.0;

    if ( ( iDirection == NIFTI_R2L ) || ( iDirection == NIFTI_L2R ) )
    {

      d00 = ( ( iDirection == NIFTI_R2L ) ? +1.0 : -1.0 );
      d03 = ( ( iDirection == NIFTI_R2L ) ? 0.0 : niftiImage->dim[1] - 1.0 );

      if ( ( jDirection == NIFTI_A2P ) || ( jDirection == NIFTI_P2A ) )
      {

        //  case i->x, j->y, k->z
        d11 = ( ( jDirection == NIFTI_A2P ) ? +1.0 : -1.0 );
        d13 = ( ( jDirection == NIFTI_A2P ) ? 0.0 : niftiImage->dim[2] - 1.0 );
        d22 = ( ( kDirection == NIFTI_S2I ) ? +1.0 : -1.0 );
        d23 = ( ( kDirection == NIFTI_S2I ) ? 0.0 : niftiImage->dim[3] - 1.0 );

      }
      else
      {

        //  case i->x, j->z, k->y
        d21 = ( ( jDirection == NIFTI_S2I ) ? +1.0 : -1.0 );
        d23 = ( ( jDirection == NIFTI_S2I ) ? 0.0 : niftiImage->dim[2] - 1.0 );
        d12 = ( ( kDirection == NIFTI_A2P ) ? +1.0 : -1.0 );
        d13 = ( ( kDirection == NIFTI_A2P ) ? 0.0 : niftiImage->dim[3] - 1.0 );

      }

    }
    else
    {

      if ( ( jDirection == NIFTI_A2P ) || ( jDirection == NIFTI_P2A ) )
      {

        //  case i->z, j->y, k->x
        d20 = ( ( iDirection == NIFTI_S2I ) ? +1.0 : -1.0 );
        d23 = ( ( iDirection == NIFTI_S2I ) ? 0.0 : niftiImage->dim[1] - 1.0 );
        d11 = ( ( jDirection == NIFTI_A2P ) ? +1.0 : -1.0 );
        d13 = ( ( jDirection == NIFTI_A2P ) ? 0.0 : niftiImage->dim[2] - 1.0 );
        d02 = ( ( kDirection == NIFTI_R2L ) ? +1.0 : -1.0 );
        d03 = ( ( kDirection == NIFTI_R2L ) ? 0.0 : niftiImage->dim[3] - 1.0 );

      }
      else
      {      

        if ( ( kDirection == NIFTI_S2I ) || ( kDirection == NIFTI_I2S ) )
        {

          //  case i->y, j->x, k->z
          d10 = ( ( iDirection == NIFTI_A2P ) ? +1.0 : -1.0 );
          d13 = ( ( iDirection == NIFTI_A2P ) ? 0.0 : niftiImage->dim[1] -1.0 );
          d01 = ( ( jDirection == NIFTI_R2L ) ? +1.0 : -1.0 );
          d03 = ( ( jDirection == NIFTI_R2L ) ? 0.0 : niftiImage->dim[2] -1.0 );
          d22 = ( ( kDirection == NIFTI_S2I ) ? +1.0 : -1.0 );
          d23 = ( ( kDirection == NIFTI_S2I ) ? 0.0 : niftiImage->dim[3] -1.0 );

        }
        else
        {

          if ( ( iDirection == NIFTI_A2P ) || ( iDirection == NIFTI_P2A ) )
          {

            //  case i->y, j->z, k->x
            d10 = ( ( iDirection == NIFTI_A2P ) ? +1.0 : -1.0 );
            d13 = ( ( iDirection == NIFTI_A2P ) ? 0.0 : niftiImage->dim[1]-1.0);
            d21 = ( ( jDirection == NIFTI_S2I ) ? +1.0 : -1.0 );
            d23 = ( ( jDirection == NIFTI_S2I ) ? 0.0 : niftiImage->dim[2]-1.0);
            d02 = ( ( kDirection == NIFTI_R2L ) ? +1.0 : -1.0 );
            d03 = ( ( kDirection == NIFTI_R2L ) ? 0.0 : niftiImage->dim[3]-1.0);

          }
          else
          {

            //  case i->z, j->x, k->y
            d20 = ( ( iDirection == NIFTI_S2I ) ? +1.0 : -1.0 );
            d23 = ( ( iDirection == NIFTI_S2I ) ? 0.0 : niftiImage->dim[1]-1.0);
            d01 = ( ( jDirection == NIFTI_R2L ) ? +1.0 : -1.0 );
            d03 = ( ( jDirection == NIFTI_R2L ) ? 0.0 : niftiImage->dim[2]-1.0);
            d12 = ( ( kDirection == NIFTI_A2P ) ? +1.0 : -1.0 );
            d13 = ( ( kDirection == NIFTI_A2P ) ? 0.0 : niftiImage->dim[3]-1.0);

          }

        }

      }

    }

    gkg::HomogeneousTransform3d< float > transform3d( d00, d01, d02, d03,
                                                      d10, d11, d12, d13,
                                                      d20, d21, d22, d23,
                                                      d30, d31, d32, d33 );
    if ( !object.getHeader().hasAttribute( "nifti_to_gkg_transform3d" ) )
    {

      object.getHeader().addAttribute( "nifti_to_gkg_transform3d",
                                       transform3d.getDirectCoefficients() ); 

    }
    else
    {

      object.getHeader()[ "nifti_to_gkg_transform3d" ] =
                                            transform3d.getDirectCoefficients(); 

    }

    // processing new size(s)
    gkg::Vector3d< float > tmp1, tmp2;
    transform3d.getDirect( gkg::Vector3d< float >( niftiImage->dim[1],
                                                   niftiImage->dim[2],
                                                   niftiImage->dim[3] ),
                                                   tmp1 );
    transform3d.getDirect( gkg::Vector3d< float >( 0.0, 0.0, 0.0 ), tmp2 );
    tmp1 -= tmp2;
    gkg::Vector3d< int32_t > newSizes( ( int32_t )rint( std::fabs( tmp1.x ) ),
                                       ( int32_t )rint( std::fabs( tmp1.y ) ),
                                       ( int32_t )rint( std::fabs( tmp1.z ) ) );
    
    // processing new resolution(s)
    transform3d.getDirect( gkg::Vector3d< float >( niftiImage->pixdim[ 1 ],
                                                   niftiImage->pixdim[2],
                                                   niftiImage->pixdim[3] ),
                                                   tmp1 );
    transform3d.getDirect( gkg::Vector3d< float >( 0.0, 0.0, 0.0 ), tmp2 );
    tmp1 -= tmp2;
    gkg::Vector3d< double > newResolutions( std::fabs( tmp1.x ),
                                            std::fabs( tmp1.y ),
                                            std::fabs( tmp1.z ) );

    // setting referential(s) and transform(s)
    std::vector< std::string > referentials;
    gkg::GenericObjectList transforms;

    gkg::Scaling3d< float > scaling3d( niftiImage->pixdim[ 1 ],
                                       niftiImage->pixdim[ 2 ],
                                       niftiImage->pixdim[ 3 ] );


    if ( niftiImage->qform_code > NIFTI_XFORM_UNKNOWN )
    {

      referentials.push_back( getReferentialName( niftiImage->qform_code ) );

      gkg::HomogeneousTransform3d< float >
                                       qto_xyz( niftiImage->qto_xyz.m[ 0 ][ 0 ],
                                                niftiImage->qto_xyz.m[ 0 ][ 1 ],
                                                niftiImage->qto_xyz.m[ 0 ][ 2 ],
                                                niftiImage->qto_xyz.m[ 0 ][ 3 ],
                                                niftiImage->qto_xyz.m[ 1 ][ 0 ],
                                                niftiImage->qto_xyz.m[ 1 ][ 1 ],
                                                niftiImage->qto_xyz.m[ 1 ][ 2 ],
                                                niftiImage->qto_xyz.m[ 1 ][ 3 ],
                                                niftiImage->qto_xyz.m[ 2 ][ 0 ],
                                                niftiImage->qto_xyz.m[ 2 ][ 1 ],
                                                niftiImage->qto_xyz.m[ 2 ][ 2 ],
                                                niftiImage->qto_xyz.m[ 2 ][ 3 ],
                                                0.0, 0.0, 0.0, 1.0 );
      transforms.push_back( transform3d.compose( scaling3d ).
                                        getInverseHomogeneousTransform3d().
                                        compose( qto_xyz ).
                                        getDirectCoefficients() );

    }
    if ( niftiImage->sform_code > NIFTI_XFORM_UNKNOWN )
    {

      referentials.push_back( getReferentialName( niftiImage->sform_code ) );

      gkg::HomogeneousTransform3d< float >
                                       sto_xyz( niftiImage->sto_xyz.m[ 0 ][ 0 ],
                                                niftiImage->sto_xyz.m[ 0 ][ 1 ],
                                                niftiImage->sto_xyz.m[ 0 ][ 2 ],
                                                niftiImage->sto_xyz.m[ 0 ][ 3 ],
                                                niftiImage->sto_xyz.m[ 1 ][ 0 ],
                                                niftiImage->sto_xyz.m[ 1 ][ 1 ],
                                                niftiImage->sto_xyz.m[ 1 ][ 2 ],
                                                niftiImage->sto_xyz.m[ 1 ][ 3 ],
                                                niftiImage->sto_xyz.m[ 2 ][ 0 ],
                                                niftiImage->sto_xyz.m[ 2 ][ 1 ],
                                                niftiImage->sto_xyz.m[ 2 ][ 2 ],
                                                niftiImage->sto_xyz.m[ 2 ][ 3 ],
                                                0.0, 0.0, 0.0, 1.0 );
      transforms.push_back( transform3d.compose( scaling3d ).
                                        getInverseHomogeneousTransform3d().
                                        compose( sto_xyz ).
                                        getDirectCoefficients() );

    }


    // consistency checks between meta-information and 
    // <*.hdr|.hdr.gz|.nii|.nii.gz>
    if ( hasStdHeader )
    {

      int32_t sizeX;
      object.getHeader().getAttribute( "sizeX", sizeX );
      if ( sizeX != newSizes.x )
      {

        throw gkg::InconsistentHeaderException(
                                         "sizeX",
                                         this->getNameWithoutExtension( name ) +
                                         ".hdr|.hdr.gz|.nii|.nii.gz" );

      }

      int32_t sizeY;
      object.getHeader().getAttribute( "sizeY", sizeY );
      if ( sizeY != newSizes.y )
      {

        throw gkg::InconsistentHeaderException(
                                         "sizeY",
                                         this->getNameWithoutExtension( name ) +
                                         ".hdr|.hdr.gz|.nii|.nii.gz" );

      }

      int32_t sizeZ;
      object.getHeader().getAttribute( "sizeZ", sizeZ );
      if ( sizeZ != newSizes.z )
      {

        throw gkg::InconsistentHeaderException(
                                         "sizeZ",
                                         this->getNameWithoutExtension( name ) +
                                         ".hdr|.hdr.gz|.nii|.nii.gz" );

      }

      int32_t sizeT;
      object.getHeader().getAttribute( "sizeT", sizeT );
      if ( sizeT != niftiImage->dim[ 4 ] )
      {

        throw gkg::InconsistentHeaderException(
                                         "sizeT",
                                         this->getNameWithoutExtension( name ) +
                                         ".hdr|.hdr.gz|.nii|.nii.gz" );

      }

      if ( object.getHeader().hasAttribute( "resolutionX" ) )
      {

        double resolutionX;
        object.getHeader().getAttribute( "resolutionX", resolutionX );
        if ( !gkg::equal( resolutionX,
                          newResolutions.x, 1e-4 ) )
        {

          throw gkg::InconsistentHeaderException(
                                         "resolutionX",
                                         this->getNameWithoutExtension( name ) +
                                         ".hdr|.hdr.gz|.nii|.nii.gz" );

        }

      }

      if ( object.getHeader().hasAttribute( "resolutionY" ) )
      {

        double resolutionY;
        object.getHeader().getAttribute( "resolutionY", resolutionY );
        if ( !gkg::equal( resolutionY,
                          newResolutions.y, 1e-4 ) )
        {

          throw gkg::InconsistentHeaderException(
                                         "resolutionY",
                                         this->getNameWithoutExtension( name ) +
                                         ".hdr|.hdr.gz|.nii|.nii.gz" );

        }

      }

      if ( object.getHeader().hasAttribute( "resolutionZ" ) )
      {

        double resolutionZ;
        object.getHeader().getAttribute( "resolutionZ", resolutionZ );
        if ( !gkg::equal( resolutionZ,
                          newResolutions.z, 1e-4 ) )
        {

          throw gkg::InconsistentHeaderException(
                                         "resolutionZ",
                                         this->getNameWithoutExtension( name ) +
                                         ".hdr|.hdr.gz|.nii|.nii.gz" );

        }

      }

      if ( object.getHeader().hasAttribute( "resolutionT" ) )
      {

        double resolutionT;
        object.getHeader().getAttribute( "resolutionT", resolutionT );
        if ( !gkg::equal( resolutionT,
                          ( double )niftiImage->pixdim[ 4 ], 1e-4 ) )
        {

          throw gkg::InconsistentHeaderException(
                                         "resolutionT",
                                         this->getNameWithoutExtension( name ) +
                                         ".hdr|.hdr.gz|.nii|.nii.gz" );

        }

      }

    }
    else
    {

      // putting the <*.hdr|.hdr.gz|.nii|.nii.gz> informations into the object 
      // header
      object.getHeader()[ "sizeX" ] = newSizes.x;
      object.getHeader()[ "sizeY" ] = newSizes.y;
      object.getHeader()[ "sizeZ" ] = newSizes.z;
      object.getHeader()[ "sizeT" ] = niftiImage->dim[ 4 ];

    }
    if ( !object.getHeader().hasAttribute( "resolutionX" ) )
    {

      object.getHeader().addAttribute( "resolutionX",
                                       newResolutions.x );

    }
    if ( !object.getHeader().hasAttribute( "resolutionY" ) )
    {

      object.getHeader().addAttribute( "resolutionY",
                                       newResolutions.y );

    }
    if ( !object.getHeader().hasAttribute( "resolutionZ" ) )
    {

      object.getHeader().addAttribute( "resolutionZ",
                                       newResolutions.z );

    }
    if ( !object.getHeader().hasAttribute( "resolutionT" ) )
    {

      object.getHeader().addAttribute( "resolutionT",
                                       ( double )niftiImage->pixdim[ 4 ] );

    }

    if ( !object.getHeader().hasAttribute( "referentials" ) )
    {

      object.getHeader().addAttribute( "referentials", referentials ); 

    }
    else
    {

      object.getHeader()[ "referentials" ] = referentials; 

    }


    if ( !object.getHeader().hasAttribute( "transformations" ) )
    {

      object.getHeader().addAttribute( "transformations", transforms ); 

    }
    else
    {

      object.getHeader()[ "transformations" ] = transforms; 

    }


    // deallocating nifti structure
    nifti_image_free( niftiImage );

    object.getHeader().setChanged();
    object.getHeader().notifyObservers();

  }
  GKG_CATCH( "template < class T > void gkg::NiftiDiskFormat< T >::readHeader( "
             "const std::string& name, gkg::HeaderedObject& object ) const" );

}


template < class T >
void gkg::NiftiDiskFormat< T >::writeHeader(
                                       const std::string& name,
                                       const gkg::HeaderedObject& object ) const
{

  try
  {

    // writing the meta-information header
    this->gkg::DiskFormat::writeHeader( name, object );

  }
  GKG_CATCH( "template < class T > void gkg::NiftiDiskFormat< T >::writeHeader( "
             "const std::string& name, const gkg::HeaderedObject& object ) "
             "const" );

}


template < class T >
void gkg::NiftiDiskFormat< T >::read( const std::string& name,
                                      gkg::Volume< T >& object ) const
{

  try
  {

    // reading header(s) meta-information and NIFTI header
    readHeader( name, object );

    // allocating volume
    object.allocate();

    // setting debug level for status reporting
    nifti_set_debug_level( 0 );

    // reading the NIFTI header and image
    nifti_image* niftiImage =
      nifti_image_read( this->getNameWithoutExtension( name ).c_str(), 1 );

    if ( !niftiImage )
    {

      throw gkg::FileNotFoundException( this->getNameWithoutExtension( name ) + 
                                        ".hdr|.hdr.gz|.nii|.nii.gz" );

    }

    // getting NIFTI to GKG homogeneous 3D transform
    std::vector< float > nifti_to_gkg_transform3d;
    if ( object.getHeader().hasAttribute( "nifti_to_gkg_transform3d" ) )
    {

      object.getHeader().getAttribute( "nifti_to_gkg_transform3d",
                                       nifti_to_gkg_transform3d ); 

    }
    else
    {

      throw std::runtime_error(
                        "unable to find 'nifti_to_gkg_transform3d' attribute" );

    }

    gkg::HomogeneousTransform3d< float >
      transform3d( nifti_to_gkg_transform3d );
          
    // copying data to volume
    int32_t t;
    gkg::Vector3d< float > from, to;

    T* d = ( T* )niftiImage->data;
    for ( t = 0; t < niftiImage->dim[4]; t++ )
    {

      for ( from.z = 0; from.z < niftiImage->dim[3]; from.z += 1.0 )
      {

        for ( from.y = 0; from.y < niftiImage->dim[2]; from.y += 1.0 )
        {

          for ( from.x = 0; from.x < niftiImage->dim[1]; from.x += 1.0 )
          {

            transform3d.getDirect( from, to );
            object( ( int32_t )rint( to.x ),
                    ( int32_t )rint( to.y ),
                    ( int32_t )rint( to.z ), t ) = *d;
            ++ d;

          }

        }

      }

    }

    // deallocating nifti structure
    nifti_image_free( niftiImage );

  }
  GKG_CATCH( "template < class T > "
             "void gkg::NiftiDiskFormat< T >::read( "
             "const std::string& name, gkg::Volume< T >& object ) const" );

}



template < class T >
void gkg::NiftiDiskFormat< T >::write( const std::string& name,
                                       gkg::Volume< T >& object,
                                       bool ascii ) const
{

  try
  {


    if ( ascii == true )
    {

      throw std::runtime_error(
                              "ascii mode not supported in NIFTI disk format" );

    }
    else
    {


      // first we add all NIFTI specific attributes
      object.addSemantic( "__nifti__", "resolutionX",
                          gkg::Semantic( gkg::TypeOf< double >::getName() ) );
      object.addSemantic( "__nifti__", "resolutionY",
                          gkg::Semantic( gkg::TypeOf< double >::getName() ) );
      object.addSemantic( "__nifti__", "resolutionZ",
                          gkg::Semantic( gkg::TypeOf< double >::getName() ) );
      object.addSemantic( "__nifti__", "resolutionT",
                          gkg::Semantic( gkg::TypeOf< double >::getName() ) );
      object.addSemantic( "__nifti__", "nifti_to_gkg_transform3d",
                          gkg::Semantic(
                                 gkg::TypeOf< std::vector< float > >::getName(),
                                 false,
                                 true ) );


      // collecting size(s) and resolution(s)
      int32_t sizeX = 1;
      int32_t sizeY = 1;
      int32_t sizeZ = 1;
      int32_t sizeT = 1;
      getInt32Value( "sizeX", object, sizeX, 1 );
      getInt32Value( "sizeY", object, sizeY, 1 );
      getInt32Value( "sizeZ", object, sizeZ, 1 );
      getInt32Value( "sizeT", object, sizeT, 1 );

      double resolutionX = 0.0;
      double resolutionY = 0.0;
      double resolutionZ = 0.0;
      double resolutionT = 0.0;
      getDoubleValue( "resolutionX", object, resolutionX, 1.0 );
      getDoubleValue( "resolutionY", object, resolutionY, 1.0 );
      getDoubleValue( "resolutionZ", object, resolutionZ, 1.0 );
      getDoubleValue( "resolutionT", object, resolutionT, 1.0 );

      // getting NIFTI to GKG homogeneous 3D transform
      std::vector< float > nifti_to_gkg_transform3d;
      if ( object.getHeader().hasAttribute( "nifti_to_gkg_transform3d" ) )
      {

        try
        {

          object.getHeader().getAttribute( "nifti_to_gkg_transform3d",
                                           nifti_to_gkg_transform3d ); 

        }
        catch( std::exception& )
        {

          gkg::GenericObjectList genericObjectList;
          object.getHeader().getAttribute( "nifti_to_gkg_transform3d",
                                           genericObjectList ); 
          int32_t nifti_to_gkg_transform3d_size =
                                            ( int32_t )genericObjectList.size();
          nifti_to_gkg_transform3d.resize( nifti_to_gkg_transform3d_size );

          int32_t v = 0;
          for ( v = 0; v < nifti_to_gkg_transform3d_size; v++ )
          {

            nifti_to_gkg_transform3d[ v ] =
                                   ( float )genericObjectList[ v ]->getScalar();

          }

        }

      }
      else
      {

        nifti_to_gkg_transform3d.resize( 16U );
        nifti_to_gkg_transform3d[  0 ] = -1.0;
        nifti_to_gkg_transform3d[  1 ] = 0.0;
        nifti_to_gkg_transform3d[  2 ] = 0.0;
        nifti_to_gkg_transform3d[  3 ] = ( float )( object.getSizeX() - 1 );

        nifti_to_gkg_transform3d[  4 ] = 0.0;
        nifti_to_gkg_transform3d[  5 ] = -1.0;
        nifti_to_gkg_transform3d[  6 ] = 0.0;
        nifti_to_gkg_transform3d[  7 ] = ( float )( object.getSizeY() - 1 );

        nifti_to_gkg_transform3d[  8 ] = 0.0;
        nifti_to_gkg_transform3d[  9 ] = 0.0;
        nifti_to_gkg_transform3d[ 10 ] = -1.0;
        nifti_to_gkg_transform3d[ 11 ] = ( float )( object.getSizeZ() - 1 );

        nifti_to_gkg_transform3d[ 12 ] = 0.0;
        nifti_to_gkg_transform3d[ 13 ] = 0.0;
        nifti_to_gkg_transform3d[ 14 ] = 0.0;
        nifti_to_gkg_transform3d[ 15 ] = 1.0;

      }

      gkg::HomogeneousTransform3d< float >
        niftiToGkgTransform3d( nifti_to_gkg_transform3d );

      // initializing NIFTI header
      nifti_image* niftiImage = nifti_simple_init_nim();

      // computing destination NIFTI size(s)
      gkg::Vector3d< float > v1, v2;
      niftiToGkgTransform3d.getInverse(
                              gkg::Vector3d< float >( ( float )sizeX,
                                                      ( float )sizeY,
                                                      ( float )sizeZ ),
                              v1 );
      niftiToGkgTransform3d.getInverse(
                              gkg::Vector3d< float >( 0.0f, 0.0f, 0.0f ),
                              v2 );
      gkg::Vector3d< float > niftiFloatSize = v1 - v2;
      gkg::Vector3d< int32_t >
        niftiSize( int32_t( rint( std::fabs( niftiFloatSize.x ) ) ),
                   int32_t( rint( std::fabs( niftiFloatSize.y ) ) ),
                   int32_t( rint( std::fabs( niftiFloatSize.z ) ) ) );
      int32_t niftiSizeT = sizeT;

      // adding volume dimensionality
      niftiImage->ndim = 4;
      niftiImage->dim[ 0 ] = 4;

      // storing size(s)
      niftiImage->dim[ 1 ] = niftiSize.x;
      niftiImage->dim[ 2 ] = niftiSize.y;
      niftiImage->dim[ 3 ] = niftiSize.z;
      niftiImage->dim[ 4 ] = niftiSizeT;
      niftiImage->dim[ 5 ] = 1;
      niftiImage->dim[ 6 ] = 1;
      niftiImage->dim[ 7 ] = 1;

      niftiImage->nx = niftiImage->dim[ 1 ];
      niftiImage->ny = niftiImage->dim[ 2 ];
      niftiImage->nz = niftiImage->dim[ 3 ];
      niftiImage->nt = niftiImage->dim[ 4 ];
      niftiImage->nu = 1;
      niftiImage->nv = 1;
      niftiImage->nw = 1;

      if ( niftiSizeT == 1 )
      {

        -- niftiImage->ndim;
        -- niftiImage->dim[ 0 ];

      }

      niftiImage->nvox = niftiImage->nx *
                         niftiImage->ny *
                         niftiImage->nz *
                         niftiImage->nt;

      // computing destination NIFTI resolution(s)
      niftiToGkgTransform3d.getInverse(
                              gkg::Vector3d< float >( ( float )resolutionX,
                                                      ( float )resolutionY,
                                                      ( float )resolutionZ ),
                              v1 );
      niftiToGkgTransform3d.getInverse(
                              gkg::Vector3d< float >( 0.0f, 0.0f, 0.0f ),
                              v2 );
      gkg::Vector3d< float > niftiFloatResolution = v1 - v2;
      niftiFloatResolution.x = std::fabs( niftiFloatResolution.x );
      niftiFloatResolution.y = std::fabs( niftiFloatResolution.y );
      niftiFloatResolution.z = std::fabs( niftiFloatResolution.z );
      float niftiFloatResolutionT = ( float )resolutionT;

      // storing resolution(s)
      niftiImage->pixdim[ 0 ] = 0;
      niftiImage->pixdim[ 1 ] = niftiFloatResolution.x;
      niftiImage->pixdim[ 2 ] = niftiFloatResolution.y;
      niftiImage->pixdim[ 3 ] = niftiFloatResolution.z;
      niftiImage->pixdim[ 4 ] = niftiFloatResolutionT;
      niftiImage->pixdim[ 5 ] = 1.0;
      niftiImage->pixdim[ 6 ] = 1.0;
      niftiImage->pixdim[ 7 ] = 1.0;

      niftiImage->dx = niftiImage->pixdim[ 1 ];
      niftiImage->dy = niftiImage->pixdim[ 2 ];
      niftiImage->dz = niftiImage->pixdim[ 3 ];
      niftiImage->dt = niftiImage->pixdim[ 4 ];
      niftiImage->du = 1.0;
      niftiImage->dv = 1.0;
      niftiImage->dw = 1.0;

      // setting data type
      niftiImage->datatype = this->getShortType();

      // setting bytes per pixel and swap size
      nifti_datatype_sizes( niftiImage->datatype,
                            &niftiImage->nbyper,
                            &niftiImage->swapsize );

      // setting data scaling
      getFloatValue( "nifti_scaling_slope",
                     object,
                     niftiImage->scl_slope );
      getFloatValue( "nifti_scaling_intercept",
                     object,
                     niftiImage->scl_inter );
      getFloatValue( "nifti_calibration_minimum",
                     object,
                     niftiImage->cal_min );
      getFloatValue( "nifti_calibration_maximum",
                     object,
                     niftiImage->cal_max );

      // setting MRI information
      getInt32Value( "nifti_frequency_dimension",
                     object,
                     niftiImage->freq_dim );
      getInt32Value( "nifti_phase_dimension",
                     object,
                     niftiImage->phase_dim );
      getInt32Value( "nifti_slice_dimension",
                     object,
                     niftiImage->slice_dim );
      getInt32Value( "nifti_slice_code",
                     object,
                     niftiImage->slice_code );
      getInt32Value( "nifti_slice_start",
                     object,
                     niftiImage->slice_start );
      getInt32Value( "nifti_slice_end",
                     object,
                     niftiImage->slice_end );
      getFloatValue( "nifti_slice_duration",
                     object,
                     niftiImage->slice_duration );

      // setting 3D image orientation and location
      std::vector< std::string > referentials;
      gkg::GenericObjectList genericObjectListTransform3ds;


      std::vector< std::string > newReferentials;
      std::vector< std::vector< float > > newTransform3ds;

      if ( object.getHeader().hasAttribute( "referentials" ) )
      {

        object.getHeader().getAttribute( "referentials", referentials );

      }
      if ( object.getHeader().hasAttribute( "transformations" ) )
      {

        try
        {

          object.getHeader().getAttribute( "transformations",
                                           genericObjectListTransform3ds );

        }
        catch( std::exception& )
        {

          std::vector< double > transformationItems;
          object.getHeader().getAttribute( "transformations",
                                           transformationItems );
          int32_t vectorSize = transformationItems.size();
          genericObjectListTransform3ds.resize( 1 );
          genericObjectListTransform3ds[ 0 ] = transformationItems;

        }

      }
      int32_t
        transform3dCount = ( int32_t )genericObjectListTransform3ds.size();


      // resolution transformation in memory frame
      gkg::Scaling3d< float > scaling3d( ( float )resolutionX,
                                         ( float )resolutionY,
                                         ( float )resolutionZ );

      // initializing Q and S forms
      niftiImage->qform_code = NIFTI_XFORM_UNKNOWN;
      niftiImage->sform_code = NIFTI_XFORM_UNKNOWN;

      // initializing first transformation
      std::vector< gkg::HomogeneousTransform3d< float > >
        homogeneousTransform3ds( transform3dCount );
      if ( transform3dCount )
      {

        std::vector< float > directItems = this->getDirectItems(
                                                  genericObjectListTransform3ds,
                                                  0 );
        homogeneousTransform3ds[ 0 ] = gkg::HomogeneousTransform3d< float >(
                                                                  directItems );

      }

      // nifti to GKG orientation codes
      std::vector < float > transform3dDirectCoefficients =
                                  niftiToGkgTransform3d.getDirectCoefficients();
      mat44 niftiToGkgM44;
      int32_t i, j;
      for ( i = 0; i < 4; i++ )
      {

        for ( j = 0; j < 4; j++ )
        {

          niftiToGkgM44.m[i][j] = transform3dDirectCoefficients[ 4 * i + j ];

        }

      }

      int32_t iCode, jCode, kCode;
      nifti_mat44_to_orientation( niftiToGkgM44, &iCode, &jCode, &kCode );

      // looping over transformation(s)
      int32_t t = 0;
      int32_t tPrime = 0;
      bool ok = false;
      bool skip = false;
      bool orientedNiftiToGkgTransform = false;
      bool orientedNiftiToGkgTransformBis = false;
      for ( t = 0; t < transform3dCount; t++ )
      {

        // collecting the transform of index t
        homogeneousTransform3ds[ t ] = gkg::HomogeneousTransform3d< float >(
                     this->getDirectItems( genericObjectListTransform3ds, t ) );

        // checking similarity with previous transforms
        skip = false;
        for ( tPrime = 0; tPrime < t; tPrime++ )
        {

          if ( homogeneousTransform3ds[ tPrime ] ==
               homogeneousTransform3ds[ t ] )
          {

            skip = true;
            break;

          }

        }

        // manage the current transformation
        if ( !skip )
        {

          // collecting the referential code
          int32_t referentialCode;

          if ( referentials.size() > 0 )
          {

            referentialCode = getReferentialCode( referentials[ t ] );
            newReferentials.push_back( referentials[ t ] );

          }
          else
          {

            referentialCode = NIFTI_XFORM_UNKNOWN;
            newReferentials.push_back( "Unknown referential" );

          }
          newTransform3ds.push_back(
                         homogeneousTransform3ds[ t ].getDirectCoefficients() );

          // duplicating current homogeneous 3D transform
          gkg::HomogeneousTransform3d< float >
            currentHomogeneousTransform3d( homogeneousTransform3ds[ t ] );

          std::vector< float >
            m = niftiToGkgTransform3d.compose(
                  scaling3d ).compose(
                    currentHomogeneousTransform3d ).getDirectCoefficients();

          orientedNiftiToGkgTransformBis = false;
          mat44 R;

          if ( !orientedNiftiToGkgTransform )
          {

            gkg::HomogeneousTransform3d< float >
              mi( -1.0, 0.0, 0.0, 0.0,
                   0.0,-1.0, 0.0, 0.0,
                   0.0, 0.0,-1.0, 0.0,
                   0.0, 0.0, 0.0, 1.0 );
            std::vector< float > mPrime =
                mi.compose(
                  niftiToGkgTransform3d ).compose(
                    scaling3d ).compose(
                      currentHomogeneousTransform3d ).getDirectCoefficients();

            for ( i = 0; i < 4; i++ )
            {

              for ( j = 0; j < 4; j++ )
              {

                R.m[ i ][ j ] = mPrime[ 4 * i + j ];

              }

            }

            int32_t iCode2, jCode2, kCode2;
            nifti_mat44_to_orientation( R, &iCode2, &jCode2, &kCode2 );
            orientedNiftiToGkgTransformBis = ( ( iCode == iCode2 ) &&
                                               ( jCode == jCode2 ) &&
                                               ( kCode == kCode2 ) );

          }

          for ( i = 0; i < 4; i++ )
          {

            for ( j = 0; j < 4; j++ )
            {

              R.m[ i ][ j ] = m[ 4 * i + j ];

            }

          }

          ok = false;

          if ( ( referentialCode == NIFTI_XFORM_SCANNER_ANAT ) &&
               ( niftiImage->qform_code == NIFTI_XFORM_UNKNOWN ) &&
               orientedNiftiToGkgTransformBis )
          {

            // saving transformation
            niftiImage->qform_code = referentialCode;
            nifti_mat44_to_quatern( R,
                                    &niftiImage->quatern_b,
                                    &niftiImage->quatern_c,
                                    &niftiImage->quatern_d,
                                    &niftiImage->qoffset_x,
                                    &niftiImage->qoffset_y,
                                    &niftiImage->qoffset_z,
                                    0,
                                    0,
                                    0,
                                    &niftiImage->qfac );

            // check if the matrix can actually be stored as a quaternion
            mat44 P = nifti_quatern_to_mat44( niftiImage->quatern_b,
                                              niftiImage->quatern_c,
                                              niftiImage->quatern_d,
                                              niftiImage->qoffset_x,
                                              niftiImage->qoffset_y,
                                              niftiImage->qoffset_z,
                                              niftiFloatResolution.x,
                                              niftiFloatResolution.y,
                                              niftiFloatResolution.z,
                                              niftiImage->qfac );

            ok = true;
            orientedNiftiToGkgTransform = true;
            for ( i = 0; i < 3 && ok; i++ )
            {

              for ( j = 0; j < 3; j++ )
              {

                if ( std::fabs( P.m[ i ][ j ] - R.m[ i ][ j ] ) > 1e-5 )
                {

                  // transformation does not fit as a quaternion
                  ok = false;
                  niftiImage->qform_code = NIFTI_XFORM_UNKNOWN;
                  break;

                }

              }

            }

          }
          if ( !ok && ( niftiImage->sform_code == NIFTI_XFORM_UNKNOWN ) )
          {

            ok = true;
            niftiImage->sform_code = referentialCode;
            for ( i = 0; i < 4; i++ )
            {

              for ( j = 0; j < 4; j++ )
              {

                niftiImage->sto_xyz.m[ i ][ j ] = m[ 4 * i + j ];

              }

            }

          }
          if( !ok )
          {

            std::cerr << "could not save transformation." << std::endl;

          }

        }

      }

      if ( !orientedNiftiToGkgTransform &&
           ( niftiImage->qform_code == NIFTI_XFORM_UNKNOWN ) )
      {

        gkg::HomogeneousTransform3d< float >
          mi( -1.0, 0.0, 0.0, 0.0,
               0.0,-1.0, 0.0, 0.0,
               0.0, 0.0,-1.0, 0.0,
               0.0, 0.0, 0.0, 1.0 );

        std::vector< float >
          mPrime = mi.compose( niftiToGkgTransform3d ).getDirectCoefficients();

        mat44 P;
        for ( i = 0; i < 4; i++ )
        {

          for ( j = 0; j < 4; j++ )
          {

            P.m[ i ][ j ] = mPrime[ 4 * i + j ];

          }

        }

        niftiImage->qform_code = NIFTI_XFORM_SCANNER_ANAT;
        nifti_mat44_to_quatern( P,
                                &niftiImage->quatern_b,
                                &niftiImage->quatern_c,
                                &niftiImage->quatern_d,
                                &niftiImage->qoffset_x,
                                &niftiImage->qoffset_y,
                                &niftiImage->qoffset_z,
                                0,
                                0,
                                0,
                                &niftiImage->qfac );
        niftiImage->qoffset_x = -( niftiImage->nx / 2.0 - 1.0 ) *
                                niftiImage->dx;
        niftiImage->qoffset_y = -( niftiImage->ny / 2.0 ) * niftiImage->dy;
        niftiImage->qoffset_z = -( niftiImage->nz / 2.0 ) * niftiImage->dz;

      }

      // adding new referentials and transformations

      if ( !newTransform3ds.empty() )
      {

        if ( object.getHeader().hasAttribute( "referentials" ) )
        {

          object.getHeader()[ "referentials" ] = newReferentials;

        }
        else
        {

          object.getHeader().addAttribute( "referentials", newReferentials );

        }

        if ( object.getHeader().hasAttribute( "transformations" ) )
        {

          gkg::GenericObjectList gol( newTransform3ds.size() );
          for ( i = 0; i < ( int32_t )newTransform3ds.size(); i++ )
          {

            gol[ i ] = newTransform3ds[ i ];

          }
          object.getHeader()[ "transformations" ] = gol;

        }
        else
        {

          gkg::GenericObjectList gol( newTransform3ds.size() );
          for ( i = 0; i < ( int32_t )newTransform3ds.size(); i++ )
          {

            gol[ i ] = newTransform3ds[ i ];

          }
          object.getHeader().addAttribute( "transformations", gol );

        }

      }

      object.getHeader().addAttribute( "nifti_to_gkg_transform3d",
                                niftiToGkgTransform3d.getDirectCoefficients() );

      // setting unit of spatial and temporal dimensions
      getFloatValue( "nifti_time_offset",
                     object,
                     niftiImage->toffset );
      getInt32Value( "nifti_xyz_units",
                     object,
                     niftiImage->xyz_units );
      getInt32Value( "nifti_time_units",
                     object,
                     niftiImage->time_units );

       // setting unit of spatial and temporal dimensions
      getFloatValue( "nifti_time_offset",
                     object,
                     niftiImage->toffset );
      getInt32Value( "nifti_xyz_units",
                     object,
                     niftiImage->xyz_units );
      getInt32Value( "nifti_time_units",
                     object,
                     niftiImage->time_units );

      // setting interpretation of voxel data
      getInt32Value( "nifti_intent_code",
                     object,
                     niftiImage->intent_code,
                     NIFTI_INTENT_NONE );
      getFloatValue( "nifti_intent_p1",
                     object,
                     niftiImage->intent_p1 );
      getFloatValue( "nifti_intent_p2",
                     object,
                     niftiImage->intent_p2 );
      getFloatValue( "nifti_intent_p3",
                     object,
                     niftiImage->intent_p3 );

      std::string niftiIntentName = "";
      getStringValue( "nifti_intent_name",
                      object,
                      niftiIntentName );
      if ( niftiIntentName.empty() )
      {

        niftiImage->intent_name[ 0 ] = '\0';

      }
      else
      {

        strncpy( niftiImage->intent_name, niftiIntentName.c_str(), 15 );
        niftiImage->intent_name[ 15 ] = '\0';

      }

      // setting description and auxiliary file
      std::string niftiDescription = "";
      getStringValue( "nifti_description",
                      object,
                      niftiDescription );
      if ( niftiDescription.empty() )
      {

        strcpy( niftiImage->descrip, "written with P.T.K.\0" );

      }
      else
      {

        strncpy( niftiImage->intent_name, niftiDescription.c_str(), 79 );
        niftiImage->descrip[ 79 ] = '\0';

      }

      std::string niftiAuxiliaryFile = "";
      getStringValue( "nifti_auxiliary_file",
                      object,
                      niftiAuxiliaryFile );
      if ( niftiAuxiliaryFile.empty() )
      {

        niftiImage->aux_file[ 0 ] = '\0';

      }
      else
      {

        strncpy( niftiImage->aux_file, niftiAuxiliaryFile.c_str(), 23 );
        niftiImage->aux_file[ 23 ] = '\0';

      }

      // setting header extensions (not managed in gkg!)
      niftiImage->num_ext = 0U;

      // obtaining extension
      std::string extension = ".hdr";
      char* extensionChar = nifti_find_file_extension( name.c_str() );
      if ( extensionChar )
      {

        extension = std::string( extensionChar );

      }

      if ( ( extension == ".hdr" ) ||
           ( extension == ".img" ) ||
           ( extension == ".hdr.gz" ) ||
           ( extension == ".img.gz" ) )
      {

        niftiImage->nifti_type = NIFTI_FTYPE_NIFTI1_2;

      }
      else
      {

        niftiImage->nifti_type = NIFTI_FTYPE_NIFTI1_1;

      }

      // setting file names
      nifti_set_filenames( niftiImage,
                           this->getNameWithoutExtension( name ).c_str(),
                           0, // do not check
                           1 );

      // writing header(s) meta-information
      writeHeader( name, object );

      // write Nifti header and data
      znzFile zfp = nifti_image_write_hdr_img( niftiImage, 2, "wb" );

      // don't close file because we have no other way to know it it failed
      ok = true;
      if ( znz_isnull( zfp ) )
      {

        ok = false;

      }

      if ( ok )
      {

        niftiToGkgTransform3d.getDirect(
                                        gkg::Vector3d< float >( 1.0, 0.0, 0.0 ),
                                        v1 );
        niftiToGkgTransform3d.getDirect(
                                        gkg::Vector3d< float >( 0.0, 0.0, 0.0 ),
                                        v2 );
        gkg::Vector3d< float > floatIncrement = v1 - v2;
        gkg::Vector3d< int32_t > increment( int32_t( rint( floatIncrement.x ) ),
                                            int32_t( rint( floatIncrement.y ) ),
                                            int32_t( rint( floatIncrement.z ) )
                                           );
        size_t byteCount = ( size_t )niftiImage->nx * sizeof( T );
        std::vector< T > buffer( niftiImage->nx );

        gkg::Vector3d< float > floatPoint;
        gkg::Vector3d< int32_t > point;
        T* dataPointer = 0;
        int32_t x, y, z;
        size_t writtenByteCount = 0U;
        for ( t = 0; t < niftiImage->nt; t++ )
        {

          for ( z = 0; z < niftiImage->nz; z++ )
          {

            for ( y = 0; y < niftiImage->ny; y++ )
            {

              niftiToGkgTransform3d.getDirect(
                          gkg::Vector3d< float >( 0.0, ( float )y, ( float )z ),
                          floatPoint );
              point.x = int32_t( rint( floatPoint.x ) );
              point.y = int32_t( rint( floatPoint.y ) );
              point.z = int32_t( rint( floatPoint.z ) );

              dataPointer = &buffer[ 0 ];
              for ( x = 0; x < niftiImage->nx; x++, point += increment )
              {

                *dataPointer = object( point, t );
                ++ dataPointer;

              }

              writtenByteCount = znzwrite( ( void* )&buffer[ 0 ], 1, byteCount,
                                           zfp );

              if ( writtenByteCount != byteCount )
              {

                y = niftiImage->ny;
                z = niftiImage->nz;
                t = niftiImage->nt;
                break;

              }

            }

          }

        }

        if ( znz_isnull( zfp ) )
        {

          ok = false;

        }
        else
        {

          znzclose( zfp );

        }

      }

      // unload data in the nifti_image struct
      nifti_image_unload( niftiImage );

      // deallocate the NIFTI structure
      nifti_image_free( niftiImage );

      if ( !ok )
      {

        throw std::runtime_error( "failed to write NIFTI file" );

      }

    }

  }
  GKG_CATCH( "template < class T > "
             "void gkg::NiftiDiskFormat< T >::write( "
             "const std::string& name, gkg::Volume< T >& object, "
             "bool ascii ) const" );

}


template < class T >
bool gkg::NiftiDiskFormat< T >::hasReader() const
{

  return true;

}


template < class T >
bool gkg::NiftiDiskFormat< T >::hasWriter() const
{

  return true;

}


template < class T >
std::string gkg::NiftiDiskFormat< T >::getHeaderExtension() const
{

  return std::string( ".nii" ) + 
         gkg::ConfigurationInfo::getInstance().getHeaderExtensionName();

}


template < class T >
int16_t gkg::NiftiDiskFormat< T >::getShortType() const
{

  return ( int16_t )-1;

}


template < class T >
void gkg::NiftiDiskFormat< T >::fillNiftiDictionary(
                                        nifti_image* niftiImage,
                                        gkg::Dictionary& niftiDictionary ) const
{

  try
  {

    int32_t i, j;

    niftiDictionary[ "ndim" ] = niftiImage->ndim;
    niftiDictionary[ "nx" ] = niftiImage->nx;
    niftiDictionary[ "ny" ] = niftiImage->ny;
    niftiDictionary[ "nz" ] = niftiImage->nz;
    niftiDictionary[ "nt" ] = niftiImage->nt;
    niftiDictionary[ "nu" ] = niftiImage->nu;
    niftiDictionary[ "nv" ] = niftiImage->nv;
    niftiDictionary[ "nw" ] = niftiImage->nw;
    std::vector< short > dim( 8 );
    for ( i = 0; i < 8; i++ )
    {

      dim[ i ] = niftiImage->dim[ i ];

    }
    niftiDictionary[ "dim" ] = dim;
    niftiDictionary[ "nvox" ] = niftiImage->nvox;
    niftiDictionary[ "nbyper" ] = niftiImage->nbyper;
    niftiDictionary[ "datatype" ] = niftiImage->datatype;
    niftiDictionary[ "dx" ] = niftiImage->dx;
    niftiDictionary[ "dy" ] = niftiImage->dy;
    niftiDictionary[ "dz" ] = niftiImage->dz;
    niftiDictionary[ "dt" ] = niftiImage->dt;
    niftiDictionary[ "du" ] = niftiImage->du;
    niftiDictionary[ "dv" ] = niftiImage->dv;
    niftiDictionary[ "dw" ] = niftiImage->dw;
    std::vector< float > pixdim( 8 );
    for ( i = 0; i < 8; i++ )
    {

      pixdim[ i ] = niftiImage->pixdim[ i ];

    }
    niftiDictionary[ "pixdim" ] = pixdim;
    niftiDictionary[ "scl_slope" ] = niftiImage->scl_slope;
    niftiDictionary[ "scl_inter" ] = niftiImage->scl_inter;
    niftiDictionary[ "cal_max" ] = niftiImage->cal_max;
    niftiDictionary[ "cal_min" ] = niftiImage->cal_min;
    niftiDictionary[ "qform_code" ] = niftiImage->qform_code;
    niftiDictionary[ "sform_code" ] = niftiImage->sform_code;
    niftiDictionary[ "freq_dim" ] = niftiImage->freq_dim;
    niftiDictionary[ "phase_dim" ] = niftiImage->phase_dim;
    niftiDictionary[ "slice_dim" ] = niftiImage->slice_dim;
    niftiDictionary[ "slice_code" ] = niftiImage->slice_code;
    niftiDictionary[ "slice_start" ] = niftiImage->slice_start;
    niftiDictionary[ "slice_end" ] = niftiImage->slice_end;
    niftiDictionary[ "slice_duration" ] = niftiImage->slice_duration;
    niftiDictionary[ "quatern_b" ] = niftiImage->quatern_b;
    niftiDictionary[ "quatern_c" ] = niftiImage->quatern_c;
    niftiDictionary[ "quatern_d" ] = niftiImage->quatern_d;
    niftiDictionary[ "qoffset_x" ] = niftiImage->qoffset_x;
    niftiDictionary[ "qoffset_y" ] = niftiImage->qoffset_y;
    niftiDictionary[ "qoffset_z" ] = niftiImage->qoffset_z;
    niftiDictionary[ "qfac" ] = niftiImage->qfac;
    std::vector< float > qto_xyz( 16 );
    for ( i = 0; i < 4; i++ )
    {

      for ( j = 0; j < 4; j++ )
      {

        qto_xyz[ i * 4 + j ] = niftiImage->qto_xyz.m[ i ][ j ];

      }

    }
    niftiDictionary[ "qto_xyz" ] = qto_xyz;
    std::vector< float > qto_ijk( 16 );
    for ( i = 0; i < 4; i++ )
    {

      for ( j = 0; j < 4; j++ )
      {

        qto_ijk[ i * 4 + j ] = niftiImage->qto_ijk.m[ i ][ j ];

      }

    }
    niftiDictionary[ "qto_ijk" ] = qto_ijk;
    std::vector< float > sto_xyz( 16 );
    for ( i = 0; i < 4; i++ )
    {

      for ( j = 0; j < 4; j++ )
      {

        sto_xyz[ i * 4 + j ] = niftiImage->sto_xyz.m[ i ][ j ];

      }

    }
    niftiDictionary[ "sto_xyz" ] = sto_xyz;
    std::vector< float > sto_ijk( 16 );
    for ( i = 0; i < 4; i++ )
    {

      for ( j = 0; j < 4; j++ )
      {

        sto_ijk[ i * 4 + j ] = niftiImage->sto_ijk.m[ i ][ j ];

      }

    }
    niftiDictionary[ "sto_ijk" ] = sto_ijk;
    niftiDictionary[ "toffset" ] = niftiImage->toffset;
    niftiDictionary[ "xyz_units" ] = niftiImage->xyz_units;
    niftiDictionary[ "time_units" ] = niftiImage->time_units;
    niftiDictionary[ "nifti_type" ] = niftiImage->nifti_type;
    niftiDictionary[ "intent_code" ] = niftiImage->intent_code;
    niftiDictionary[ "intent_p1" ] = niftiImage->intent_p1;
    niftiDictionary[ "intent_p2" ] = niftiImage->intent_p2;
    niftiDictionary[ "intent_p3" ] = niftiImage->intent_p3;
    niftiDictionary[ "intent_name" ] = std::string( niftiImage->intent_name );
    niftiDictionary[ "descrip" ] = std::string( niftiImage->descrip );
    niftiDictionary[ "aux_file" ] = std::string( niftiImage->aux_file );
    if ( niftiImage->fname )
    {

      niftiDictionary[ "fname" ] = std::string( niftiImage->fname );

    }
    if ( niftiImage->iname )
    {

      niftiDictionary[ "iname" ] = std::string( niftiImage->iname );

    }
    niftiDictionary[ "iname_offset" ] = niftiImage->iname_offset;
    niftiDictionary[ "swapsize" ] = niftiImage->swapsize;
    niftiDictionary[ "byteorder" ] = niftiImage->byteorder;

  }
  GKG_CATCH( "template < class T > "
             "void gkg::NiftiDiskFormat< T >::fillNiftiDictionary( "
             "nifti_image* niftiImage, "
             "gkg::Dictionary& niftiDictionary ) const" );

}


template < class T >
std::string 
gkg::NiftiDiskFormat< T >::getReferentialName( int32_t transformCode ) const
{

  try
  {

    std::string referentialName = "Unknown transformation";
    if ( transformCode == NIFTI_XFORM_UNKNOWN )
    {

      referentialName = "Arbitrary coordinates";

    }
    else if ( transformCode == NIFTI_XFORM_SCANNER_ANAT )
    {

      referentialName = "Scanner-based anatomical coordinates";

    }
    else if ( transformCode == NIFTI_XFORM_ALIGNED_ANAT )
    {

      referentialName =
                   "Coordinates aligned to another file or to anatomical truth";

    }
    else if ( transformCode == NIFTI_XFORM_TALAIRACH )
    {

      referentialName = "Talairach-AC/PC-Anatomist";

    }
    else if ( transformCode == NIFTI_XFORM_MNI_152 )
    {

      referentialName = "Talairach-MNI template-SPM";

    }

    return referentialName;

  }
  GKG_CATCH( "template < class T > "
             "std::string  "
             "gkg::NiftiDiskFormat< T >::getReferentialName( "
             "int32_t xformCode ) const" );

}


template < class T >
int32_t
gkg::NiftiDiskFormat< T >::getReferentialCode(
                                      const std::string& referentialName ) const
{

  try
  {

    int32_t referentialCode = NIFTI_XFORM_UNKNOWN;
    if ( referentialName == "Scanner-based anatomical coordinates" )
    {

      referentialCode = NIFTI_XFORM_SCANNER_ANAT;

    }
    else if ( referentialName ==
              "Coordinates aligned to another file or to anatomical truth" )
    {

      referentialCode = NIFTI_XFORM_ALIGNED_ANAT;

    }
    else if ( referentialName == "Talairach-AC/PC-Anatomist" )
    {

      referentialCode = NIFTI_XFORM_TALAIRACH;

    }
    else if ( referentialName == "Talairach-MNI template-SPM" )
    {

      referentialCode = NIFTI_XFORM_MNI_152;

    }
    else
    {

      referentialCode = NIFTI_XFORM_UNKNOWN;

    }

    return referentialCode;

  }
  GKG_CATCH( "template < class T > "
             "int32_t "
             "gkg::NiftiDiskFormat< T >::getReferentialCode( "
             "const std::string& referentialName ) const" );

}


template < class T >
void gkg::NiftiDiskFormat< T >::getInt32Value(
                                              const std::string& name,
                                              const gkg::HeaderedObject& object,
                                              int32_t& value,
                                              int32_t defaultValue ) const
{

  try
  {

    value = defaultValue;
    if ( object.getHeader().hasAttribute( name ) )
    {

      object.getHeader().getAttribute( name, value );

    }

  }
  GKG_CATCH( "template < class T > "
             "void gkg::NiftiDiskFormat< T >::getInt32Value( "
             "const std::string& name, "
             "const gkg::HeaderedObject& object, "
             "int32_t& value, "
             "int32_t defaultValue ) const" );

}


template < class T >
void gkg::NiftiDiskFormat< T >::getFloatValue(
                                              const std::string& name,
                                              const gkg::HeaderedObject& object,
                                              float& value,
                                              float defaultValue ) const
{

  try
  {

    value = defaultValue;
    if ( object.getHeader().hasAttribute( name ) )
    {

      object.getHeader().getAttribute( name, value );

    }

  }
  GKG_CATCH( "template < class T > "
             "void gkg::NiftiDiskFormat< T >::getFloatValue( "
             "const std::string& name, "
             "const gkg::HeaderedObject& object, "
             "float& value, "
             "float defaultValue ) const" );

}


template < class T >
void gkg::NiftiDiskFormat< T >::getDoubleValue(
                                              const std::string& name,
                                              const gkg::HeaderedObject& object,
                                              double& value,
                                              double defaultValue ) const
{

  try
  {

    value = defaultValue;
    if ( object.getHeader().hasAttribute( name ) )
    {

      object.getHeader().getAttribute( name, value );

    }

  }
  GKG_CATCH( "template < class T > "
             "void gkg::NiftiDiskFormat< T >::getDoubleValue( "
             "const std::string& name, "
             "const gkg::HeaderedObject& object, "
             "double& value, "
             "double defaultValue ) const" );

}


template < class T >
void gkg::NiftiDiskFormat< T >::getStringValue(
                                         const std::string& name,
                                         const gkg::HeaderedObject& object,
                                         std::string& value,
                                         const std::string& defaultValue ) const
{

  try
  {

    value = defaultValue;
    if ( object.getHeader().hasAttribute( name ) )
    {

      object.getHeader().getAttribute( name, value );

    }

  }
  GKG_CATCH( "template < class T > "
             "void gkg::NiftiDiskFormat< T >::getStringValue( "
             "const std::string& name, "
             "const gkg::HeaderedObject& object, "
             "std::string& value, "
             "const std::string& defaultValue ) const" );

}


template < class T >
std::vector< float > gkg::NiftiDiskFormat< T >::getDirectItems(
                                             gkg::GenericObjectList& transforms,
                                             int32_t index ) const
{

  try
  {

    std::vector< float > directItems;
    try
    {

      directItems =
               transforms[ index ]->template getValue< std::vector< float > >();

    }
    catch( std::exception& )
    {

      try
      {

        std::vector< double > directItemsDouble;
        directItemsDouble =
              transforms[ index ]->template getValue< std::vector< double > >();

        int32_t nbItems = directItemsDouble.size();
        directItems.resize( nbItems );

        for ( int32_t i = 0 ; i < nbItems ; ++ i )
        {

          directItems[ i ] = (float)directItemsDouble[ i ];

        }

      }
      catch( std::exception& )
      {

        gkg::GenericObjectList genericObjectListDirectItems =
             transforms[ index ]->template getValue< gkg::GenericObjectList >();

        int32_t directItemSize = ( int32_t )genericObjectListDirectItems.size();
        directItems.resize( directItemSize );
        for ( int32_t v = 0; v < directItemSize; v++ )
        {

          directItems[ v ] =
                      ( float )genericObjectListDirectItems[ v ]->getScalar();

        }

      }

    }

    return directItems;

  }
  GKG_CATCH( "template < class T > "
             "std::vector< float > gkg::NiftiDiskFormat< T >::getDirectItems( "
             "const gkg::GenericObjectList& transforms, "
             "int32_t index ) const" );

}


// specializations


// boolean are managed as single bit, so we must get or put boolean items once 
// a time and we cannot use a pointer to boolean items
// boolean are managed as single bit, so we must write boolean items once a time
// and we cannot use a pointer to boolean items

namespace gkg
{


template <>
inline
std::string NiftiDiskFormat< int8_t >::getTypeName() const
{

  return "S8";

}


template <>
inline
std::string NiftiDiskFormat< uint8_t >::getTypeName() const
{

  return "U8";

}


template <>
inline
std::string NiftiDiskFormat< int16_t >::getTypeName() const
{

  return "S16";

}


template <>
inline
std::string NiftiDiskFormat< uint16_t >::getTypeName() const
{

  return "U16";

}


template <>
inline
std::string NiftiDiskFormat< int32_t >::getTypeName() const
{

  return "S32";

}


template <>
inline
std::string NiftiDiskFormat< uint32_t >::getTypeName() const
{

  return "U32";

}


template <>
inline
std::string NiftiDiskFormat< int64_t >::getTypeName() const
{

  return "S64";

}


template <>
inline
std::string NiftiDiskFormat< uint64_t >::getTypeName() const
{

  return "U64";

}


template <>
inline
std::string NiftiDiskFormat< float >::getTypeName() const
{

  return "FLOAT";

}


template <>
inline
std::string NiftiDiskFormat< double >::getTypeName() const
{

  return "DOUBLE";

}


template <>
inline
std::string NiftiDiskFormat< bool >::getTypeName() const
{

  return "BOOLEAN";

}


template <>
int16_t NiftiDiskFormat< int8_t >::getShortType() const
{

  return DT_INT8;

}


template <>
short NiftiDiskFormat< uint8_t >::getShortType() const
{

  return DT_UINT8;

}


template <>
short NiftiDiskFormat< int16_t >::getShortType() const
{

  return DT_INT16;

}


template <>
short NiftiDiskFormat< uint16_t >::getShortType() const
{

  return DT_UINT16;

}


template <>
short NiftiDiskFormat< int32_t >::getShortType() const
{

  return DT_INT32;

}


template <>
short NiftiDiskFormat< uint32_t >::getShortType() const
{

  return DT_UINT32;

}


template <>
short NiftiDiskFormat< float >::getShortType() const
{

  return DT_FLOAT32;

}


template <>
short NiftiDiskFormat< double >::getShortType() const
{

  return DT_DOUBLE;

}


}


//
// NIFTI disk format singleton instanciation
//

template class gkg::NiftiDiskFormat< int8_t >;
template class gkg::NiftiDiskFormat< uint8_t >;
template class gkg::NiftiDiskFormat< int16_t >;
template class gkg::NiftiDiskFormat< uint16_t >;
template class gkg::NiftiDiskFormat< int32_t >;
template class gkg::NiftiDiskFormat< uint32_t >;
template class gkg::NiftiDiskFormat< float >;
template class gkg::NiftiDiskFormat< double >;


//
// registrating standard NIFTI disk format(s) for "Volume" object factory
//

static bool initialize()
{

  try
  {

    gkg::DiskFormatFactory< gkg::Volume< int8_t > 
                          >::getInstance().registerDiskFormat(
         gkg::NiftiDiskFormat< int8_t >::getInstance().getName(),
         &gkg::NiftiDiskFormat< int8_t >::getInstance() );
    gkg::DiskFormatFactory< gkg::Volume< uint8_t > 
                          >::getInstance().registerDiskFormat(
         gkg::NiftiDiskFormat< uint8_t >::getInstance().getName(),
         &gkg::NiftiDiskFormat< uint8_t >::getInstance() );
    gkg::DiskFormatFactory< gkg::Volume< int16_t > 
                          >::getInstance().registerDiskFormat(
         gkg::NiftiDiskFormat< int16_t >::getInstance().getName(),
         &gkg::NiftiDiskFormat< int16_t >::getInstance() );
    gkg::DiskFormatFactory< gkg::Volume< uint16_t > 
                          >::getInstance().registerDiskFormat(
         gkg::NiftiDiskFormat< uint16_t >::getInstance().getName(),
         &gkg::NiftiDiskFormat< uint16_t >::getInstance() );
    gkg::DiskFormatFactory< gkg::Volume< int32_t > 
                          >::getInstance().registerDiskFormat(
         gkg::NiftiDiskFormat< int32_t >::getInstance().getName(),
         &gkg::NiftiDiskFormat< int32_t >::getInstance() );
    gkg::DiskFormatFactory< gkg::Volume< uint32_t > 
                          >::getInstance().registerDiskFormat(
         gkg::NiftiDiskFormat< uint32_t >::getInstance().getName(),
         &gkg::NiftiDiskFormat< uint32_t >::getInstance() );
    gkg::DiskFormatFactory< gkg::Volume< float > 
                          >::getInstance().registerDiskFormat(
         gkg::NiftiDiskFormat< float >::getInstance().getName(),
         &gkg::NiftiDiskFormat< float >::getInstance() );
    gkg::DiskFormatFactory< gkg::Volume< double > 
                          >::getInstance().registerDiskFormat(
         gkg::NiftiDiskFormat< double >::getInstance().getName(),
         &gkg::NiftiDiskFormat< double >::getInstance() );

    return true;

  }
  GKG_CATCH( "NIFTI disk format registration: " )

}

static bool initialized = initialize();
